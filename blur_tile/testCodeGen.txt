Injecting realization of sum$4
Injecting realization of blur_root3
Injecting realization of sum$3
Injecting realization of blur_root2
Injecting realization of sum$2
Injecting realization of blur_root1
Injecting realization of sum
Injecting realization of blur_root0
Injecting tracing...
Injecting profiling...
Adding checks for parameters
Computing bounds of each function's value
Adding checks for images
Performing computation bounds inference...
Performing sliding window optimization...
Performing allocation bounds inference...
Uniquifying variable names...
Performing storage folding optimization...
Injecting debug_to_file calls...
Simplifying...
Dynamically skipping stages...
Performing storage flattening...
Removing code that depends on undef values...
Simplifying...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Specializing clamped ramps...
Injecting early frees...
Simplifying...
Lowering after final simplification:
let blur_root4.extent.0.required.s = (min((((((blur_root4.extent.0 + -1)/4)*4) + blur_root4.min.0) + 3), ((blur_root4.min.0 + blur_root4.extent.0) + -1)) - min(blur_root4.min.0, ((blur_root4.min.0 + blur_root4.extent.0) + -4)))
let blur_root4.min.0.required = min(blur_root4.min.0, ((blur_root4.min.0 + blur_root4.extent.0) + -4))
let blur_root4.extent.1.required.s = (min((((((blur_root4.extent.1 + -1)/4)*4) + blur_root4.min.1) + 3), ((blur_root4.min.1 + blur_root4.extent.1) + -1)) - min(blur_root4.min.1, ((blur_root4.min.1 + blur_root4.extent.1) + -4)))
let blur_root4.min.1.required = min(blur_root4.min.1, ((blur_root4.min.1 + blur_root4.extent.1) + -4))
let p0.extent.0.required.s = (max(min(((blur_root4.min.0 + blur_root4.extent.0) + 3), (p0.extent.0 + -1)), 0) - max(min((blur_root4.min.0 + -4), (p0.extent.0 + -1)), 0))
let p0.min.0.required = max(min((blur_root4.min.0 + -4), (p0.extent.0 + -1)), 0)
let p0.extent.1.required.s = (max(min(((blur_root4.min.1 + blur_root4.extent.1) + 3), (p0.extent.1 + -1)), 0) - max(min((blur_root4.min.1 + -4), (p0.extent.1 + -1)), 0))
let p0.min.1.required = max(min((blur_root4.min.1 + -4), (p0.extent.1 + -1)), 0)
if (blur_root4.host_and_dev_are_null) {
  rewrite_buffer(blur_root4.buffer, 2, blur_root4.min.0.required, (blur_root4.extent.0.required.s + 1), 1, blur_root4.min.1.required, (blur_root4.extent.1.required.s + 1), (blur_root4.extent.0.required.s + 1))
}
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 3, 1, 0, 3, 3)
}
if (p0.host_and_dev_are_null) {
  rewrite_buffer(p0.buffer, 2, p0.min.0.required, (p0.extent.0.required.s + 1), 1, p0.min.1.required, (p0.extent.1.required.s + 1), (p0.extent.0.required.s + 1))
}
if (!((blur_root4.host_and_dev_are_null || i0.host_and_dev_are_null) || p0.host_and_dev_are_null)) {
  assert((blur_root4.elem_size == 2), "Output buffer blur_root4 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", blur_root4.elem_size)
  assert((i0.elem_size == 2), "Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", i0.elem_size)
  assert((p0.elem_size == 2), "Input buffer p0 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", p0.elem_size)
  assert((blur_root4.min.0 <= blur_root4.min.0.required), "Output buffer blur_root4 is accessed at %d, which is before the min (%d) in dimension 0", blur_root4.min.0.required, blur_root4.min.0)
  assert(((((blur_root4.min.0.required + blur_root4.extent.0.required.s) - blur_root4.extent.0) + 1) <= blur_root4.min.0), "Output buffer blur_root4 is accessed at %d, which is beyond the max (%d) in dimension 0", (blur_root4.min.0.required + blur_root4.extent.0.required.s), ((blur_root4.min.0 + blur_root4.extent.0) + -1))
  assert((blur_root4.min.1 <= blur_root4.min.1.required), "Output buffer blur_root4 is accessed at %d, which is before the min (%d) in dimension 1", blur_root4.min.1.required, blur_root4.min.1)
  assert(((((blur_root4.min.1.required + blur_root4.extent.1.required.s) - blur_root4.extent.1) + 1) <= blur_root4.min.1), "Output buffer blur_root4 is accessed at %d, which is beyond the max (%d) in dimension 1", (blur_root4.min.1.required + blur_root4.extent.1.required.s), ((blur_root4.min.1 + blur_root4.extent.1) + -1))
  assert((i0.min.0 <= 0), "Input buffer i0 is accessed at %d, which is before the min (%d) in dimension 0", 0, i0.min.0)
  assert(((3 - i0.extent.0) <= i0.min.0), "Input buffer i0 is accessed at %d, which is beyond the max (%d) in dimension 0", 2, ((i0.min.0 + i0.extent.0) + -1))
  assert((i0.min.1 <= 0), "Input buffer i0 is accessed at %d, which is before the min (%d) in dimension 1", 0, i0.min.1)
  assert(((3 - i0.extent.1) <= i0.min.1), "Input buffer i0 is accessed at %d, which is beyond the max (%d) in dimension 1", 2, ((i0.min.1 + i0.extent.1) + -1))
  assert((p0.min.0 <= p0.min.0.required), "Input buffer p0 is accessed at %d, which is before the min (%d) in dimension 0", p0.min.0.required, p0.min.0)
  assert(((((p0.min.0.required + p0.extent.0.required.s) - p0.extent.0) + 1) <= p0.min.0), "Input buffer p0 is accessed at %d, which is beyond the max (%d) in dimension 0", (p0.min.0.required + p0.extent.0.required.s), ((p0.min.0 + p0.extent.0) + -1))
  assert((p0.min.1 <= p0.min.1.required), "Input buffer p0 is accessed at %d, which is before the min (%d) in dimension 1", p0.min.1.required, p0.min.1)
  assert(((((p0.min.1.required + p0.extent.1.required.s) - p0.extent.1) + 1) <= p0.min.1), "Input buffer p0 is accessed at %d, which is beyond the max (%d) in dimension 1", (p0.min.1.required + p0.extent.1.required.s), ((p0.min.1 + p0.extent.1) + -1))
  assert((blur_root4.stride.0 == 1), "Static constraint violated: blur_root4.stride.0 == 1")
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 3), "Static constraint violated: i0.extent.0 == 3")
  assert((i0.stride.1 == 3), "Static constraint violated: i0.stride.1 == 3")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 3), "Static constraint violated: i0.extent.1 == 3")
  assert((p0.stride.0 == 1), "Static constraint violated: p0.stride.0 == 1")
  let blur_root4.total_extent.1 = (int64(blur_root4.extent.1)*int64(blur_root4.extent.0))
  let p0.total_extent.1 = (int64(p0.extent.1)*int64(p0.extent.0))
  assert((int64(blur_root4.extent.0) <= int64(2147483647)), "Total allocation for buffer blur_root4 exceeds 2^31 - 1")
  assert(((int64(blur_root4.extent.1)*int64(blur_root4.stride.1)) <= int64(2147483647)), "Total allocation for buffer blur_root4 exceeds 2^31 - 1")
  assert((blur_root4.total_extent.1 <= int64(2147483647)), "Product of extents for buffer blur_root4 exceeds 2^31 - 1")
  assert((int64(3) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(3)*int64(3)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(3)*int64(3)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(p0.extent.0) <= int64(2147483647)), "Total allocation for buffer p0 exceeds 2^31 - 1")
  assert(((int64(p0.extent.1)*int64(p0.stride.1)) <= int64(2147483647)), "Total allocation for buffer p0 exceeds 2^31 - 1")
  assert((p0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer p0 exceeds 2^31 - 1")
  let blur_root0.y.min_realized = min((blur_root4.min.1 + -4), (min((blur_root4.min.1 + -3), ((blur_root4.min.1 + blur_root4.extent.1) + -1)) + -1))
  let blur_root0.y.extent_realized.s.s = max(((blur_root4.min.1 + blur_root4.extent.1) + 3), (min(((((blur_root4.extent.1 + 5)/4)*4) + blur_root4.min.1), ((blur_root4.min.1 + blur_root4.extent.1) + 2)) + 1))
  let blur_root0.x.min_realized = min((blur_root4.min.0 + -4), (min((blur_root4.min.0 + -3), ((blur_root4.min.0 + blur_root4.extent.0) + -1)) + -1))
  let blur_root0.x.extent_realized.s.s = max(((blur_root4.min.0 + blur_root4.extent.0) + 3), (min(((((blur_root4.extent.0 + 5)/4)*4) + blur_root4.min.0), ((blur_root4.min.0 + blur_root4.extent.0) + 2)) + 1))
  allocate blur_root0[uint16 * ((blur_root0.x.extent_realized.s.s - blur_root0.x.min_realized) + 1) * ((blur_root0.y.extent_realized.s.s - blur_root0.y.min_realized) + 1)]
  produce blur_root0 {
    for (blur_root0.s0.y, (blur_root4.min.1 + -4), (blur_root4.extent.1 + 8)) {
      for (blur_root0.s0.x, (blur_root4.min.0 + -4), (blur_root4.extent.0 + 8)) {
        blur_root0[((blur_root0.s0.x - blur_root0.x.min_realized) + ((blur_root0.s0.y - blur_root0.y.min_realized)*((blur_root0.x.extent_realized.s.s - blur_root0.x.min_realized) + 1)))] = p0[((max(min(blur_root0.s0.x, (p0.extent.0 + -1)), 0) + (max(min(blur_root0.s0.y, (p0.extent.1 + -1)), 0)*p0.stride.1)) - (p0.min.0 + (p0.min.1*p0.stride.1)))]
      }
    }
  }
  let blur_root1.y.min_realized = min(min((blur_root4.min.1 + -3), ((blur_root4.min.1 + blur_root4.extent.1) + -1)), (min(blur_root4.min.1, (blur_root4.min.1 + blur_root4.extent.1)) + -3))
  let blur_root1.y.extent_realized.s.s = max(min(((((blur_root4.extent.1 + 5)/4)*4) + blur_root4.min.1), ((blur_root4.min.1 + blur_root4.extent.1) + 2)), ((blur_root4.extent.1 + blur_root4.min.1) + 2))
  let blur_root1.x.min_realized = min(min((blur_root4.min.0 + -3), ((blur_root4.min.0 + blur_root4.extent.0) + -1)), (min(blur_root4.min.0, (blur_root4.min.0 + blur_root4.extent.0)) + -3))
  let blur_root1.x.extent_realized.s.s = max(min(((((blur_root4.extent.0 + 5)/4)*4) + blur_root4.min.0), ((blur_root4.min.0 + blur_root4.extent.0) + 2)), ((blur_root4.extent.0 + blur_root4.min.0) + 2))
  allocate blur_root1[uint16 * ((blur_root1.x.extent_realized.s.s - blur_root1.x.min_realized) + 1) * ((blur_root1.y.extent_realized.s.s - blur_root1.y.min_realized) + 1)]
  produce blur_root1 {
    parallel (blur_root1.s0.y.y, 0, ((blur_root4.extent.1 + 9)/4)) {
      let blur_root1.s0.y.v10.base = min((((blur_root1.s0.y.y*4) + blur_root4.min.1) + -3), ((blur_root4.min.1 + blur_root4.extent.1) + -1))
      for (blur_root1.s0.y.v10, 0, 4) {
        for (blur_root1.s0.x.x, 0, ((blur_root4.extent.0 + 9)/4)) {
          let blur_root1.s0.x.v11.base = min((((blur_root1.s0.x.x*4) + blur_root4.min.0) + -3), ((blur_root4.min.0 + blur_root4.extent.0) + -1))
          allocate sum[uint16 * 4 * 1 * 1]
          produce sum {
            sum[ramp(0, 1, 4)] = x4(uint16(0))
          } update sum {
            for (sum.s1.i0.y$r, 0, 3) {
              for (sum.s1.i0.x$r, 0, 3) {
                sum[ramp(0, 1, 4)] = (sum[ramp(0, 1, 4)] + (x4(i0[(sum.s1.i0.x$r + (sum.s1.i0.y$r*3))])*blur_root0[ramp(((((blur_root1.s0.x.v11.base + sum.s1.i0.x$r) - blur_root0.x.min_realized) + (((((blur_root1.s0.y.v10.base + blur_root1.s0.y.v10) + sum.s1.i0.y$r) - blur_root0.y.min_realized) + -1)*((blur_root0.x.extent_realized.s.s - blur_root0.x.min_realized) + 1))) + -1), 1, 4)]))
              }
            }
          }
          blur_root1[ramp(((blur_root1.s0.x.v11.base - blur_root1.x.min_realized) + (((blur_root1.s0.y.v10.base + blur_root1.s0.y.v10) - blur_root1.y.min_realized)*((blur_root1.x.extent_realized.s.s - blur_root1.x.min_realized) + 1))), 1, 4)] = sum[ramp(0, 1, 4)]
          free sum
        }
      }
    }
    free blur_root0
  }
  let blur_root2.y.min_realized = min((min(blur_root4.min.1, (blur_root4.min.1 + blur_root4.extent.1)) + -2), (min((blur_root4.min.1 + -1), ((blur_root4.min.1 + blur_root4.extent.1) + -3)) + -1))
  let blur_root2.y.extent_realized.s.s = max((blur_root4.extent.1 + blur_root4.min.1), min((((((blur_root4.extent.1 + 1)/4)*4) + blur_root4.min.1) + 2), (blur_root4.min.1 + blur_root4.extent.1)))
  let blur_root2.x.min_realized = min((min(blur_root4.min.0, (blur_root4.min.0 + blur_root4.extent.0)) + -2), (min((blur_root4.min.0 + -1), ((blur_root4.min.0 + blur_root4.extent.0) + -3)) + -1))
  let blur_root2.x.extent_realized.s.s = max((blur_root4.extent.0 + blur_root4.min.0), min((((((blur_root4.extent.0 + 1)/4)*4) + blur_root4.min.0) + 2), (blur_root4.min.0 + blur_root4.extent.0)))
  allocate blur_root2[uint16 * ((blur_root2.x.extent_realized.s.s - blur_root2.x.min_realized) + 2) * ((blur_root2.y.extent_realized.s.s - blur_root2.y.min_realized) + 2)]
  produce blur_root2 {
    parallel (blur_root2.s0.y.y, 0, ((blur_root4.extent.1 + 7)/4)) {
      let blur_root2.s0.y.v12.base.s = min((blur_root2.s0.y.y*4), blur_root4.extent.1)
      for (blur_root2.s0.y.v12, 0, 4) {
        for (blur_root2.s0.x.x, 0, ((blur_root4.extent.0 + 7)/4)) {
          let blur_root2.s0.x.v13.base.s = min((blur_root2.s0.x.x*4), blur_root4.extent.0)
          allocate sum$2[uint16 * 4 * 1 * 1]
          produce sum$2 {
            sum$2[ramp(0, 1, 4)] = x4(uint16(0))
          } update sum$2 {
            for (sum$2.s1.i0.y$r, 0, 3) {
              for (sum$2.s1.i0.x$r, 0, 3) {
                sum$2[ramp(0, 1, 4)] = (sum$2[ramp(0, 1, 4)] + (x4(i0[(sum$2.s1.i0.x$r + (sum$2.s1.i0.y$r*3))])*blur_root1[ramp((((((blur_root2.s0.x.v13.base.s + blur_root4.min.0) + sum$2.s1.i0.x$r) - blur_root1.x.min_realized) + ((((((blur_root2.s0.y.v12.base.s + blur_root4.min.1) + blur_root2.s0.y.v12) + sum$2.s1.i0.y$r) - blur_root1.y.min_realized) + -3)*((blur_root1.x.extent_realized.s.s - blur_root1.x.min_realized) + 1))) + -3), 1, 4)]))
              }
            }
          }
          blur_root2[ramp(((((blur_root2.s0.x.v13.base.s + blur_root4.min.0) - blur_root2.x.min_realized) + (((((blur_root2.s0.y.v12.base.s + blur_root4.min.1) + blur_root2.s0.y.v12) - blur_root2.y.min_realized) + -2)*((blur_root2.x.extent_realized.s.s - blur_root2.x.min_realized) + 2))) + -2), 1, 4)] = sum$2[ramp(0, 1, 4)]
          free sum$2
        }
      }
    }
    free blur_root1
  }
  let blur_root3.y.min_realized = min(min((blur_root4.min.1 + -1), ((blur_root4.min.1 + blur_root4.extent.1) + -3)), (blur_root4.min.1.required + -1))
  let blur_root3.y.extent_realized.s = (min(max((((((blur_root4.extent.1 + 1)/4)*4) + blur_root4.min.1) + 2), (((((blur_root4.extent.1 + -1)/4)*4) + blur_root4.min.1) + 4)), (blur_root4.min.1 + blur_root4.extent.1)) - min(min((blur_root4.min.1 + -1), ((blur_root4.min.1 + blur_root4.extent.1) + -3)), (blur_root4.min.1.required + -1)))
  let blur_root3.x.min_realized = min(min((blur_root4.min.0 + -1), ((blur_root4.min.0 + blur_root4.extent.0) + -3)), (blur_root4.min.0.required + -1))
  let blur_root3.x.extent_realized.s = (min(max((((((blur_root4.extent.0 + 1)/4)*4) + blur_root4.min.0) + 2), (((((blur_root4.extent.0 + -1)/4)*4) + blur_root4.min.0) + 4)), (blur_root4.min.0 + blur_root4.extent.0)) - min(min((blur_root4.min.0 + -1), ((blur_root4.min.0 + blur_root4.extent.0) + -3)), (blur_root4.min.0.required + -1)))
  allocate blur_root3[uint16 * (blur_root3.x.extent_realized.s + 1) * (blur_root3.y.extent_realized.s + 1)]
  produce blur_root3 {
    parallel (blur_root3.s0.y.y, 0, ((blur_root4.extent.1 + 5)/4)) {
      let blur_root3.s0.y.v14.base = min((((blur_root3.s0.y.y*4) + blur_root4.min.1) + -1), ((blur_root4.min.1 + blur_root4.extent.1) + -3))
      for (blur_root3.s0.y.v14, 0, 4) {
        for (blur_root3.s0.x.x, 0, ((blur_root4.extent.0 + 5)/4)) {
          let blur_root3.s0.x.v15.base = min((((blur_root3.s0.x.x*4) + blur_root4.min.0) + -1), ((blur_root4.min.0 + blur_root4.extent.0) + -3))
          allocate sum$3[uint16 * 4 * 1 * 1]
          produce sum$3 {
            sum$3[ramp(0, 1, 4)] = x4(uint16(0))
          } update sum$3 {
            for (sum$3.s1.i0.y$r, 0, 3) {
              for (sum$3.s1.i0.x$r, 0, 3) {
                sum$3[ramp(0, 1, 4)] = (sum$3[ramp(0, 1, 4)] + (x4(i0[(sum$3.s1.i0.x$r + (sum$3.s1.i0.y$r*3))])*blur_root2[ramp(((((blur_root3.s0.x.v15.base + sum$3.s1.i0.x$r) - blur_root2.x.min_realized) + (((((blur_root3.s0.y.v14.base + blur_root3.s0.y.v14) + sum$3.s1.i0.y$r) - blur_root2.y.min_realized) + -1)*((blur_root2.x.extent_realized.s.s - blur_root2.x.min_realized) + 2))) + -1), 1, 4)]))
              }
            }
          }
          blur_root3[ramp(((blur_root3.s0.x.v15.base - blur_root3.x.min_realized) + (((blur_root3.s0.y.v14.base + blur_root3.s0.y.v14) - blur_root3.y.min_realized)*(blur_root3.x.extent_realized.s + 1))), 1, 4)] = sum$3[ramp(0, 1, 4)]
          free sum$3
        }
      }
    }
    free blur_root2
  }
  produce blur_root4 {
    parallel (blur_root4.s0.y.y, 0, ((blur_root4.extent.1 + 3)/4)) {
      let blur_root4.s0.y.v16.base = min(((blur_root4.s0.y.y*4) + blur_root4.min.1), ((blur_root4.min.1 + blur_root4.extent.1) + -4))
      for (blur_root4.s0.y.v16, 0, 4) {
        for (blur_root4.s0.x.x, 0, ((blur_root4.extent.0 + 3)/4)) {
          let blur_root4.s0.x.v17.base = min(((blur_root4.s0.x.x*4) + blur_root4.min.0), ((blur_root4.min.0 + blur_root4.extent.0) + -4))
          allocate sum$4[uint16 * 4 * 1 * 1]
          produce sum$4 {
            sum$4[ramp(0, 1, 4)] = x4(uint16(0))
          } update sum$4 {
            for (sum$4.s1.i0.y$r, 0, 3) {
              for (sum$4.s1.i0.x$r, 0, 3) {
                sum$4[ramp(0, 1, 4)] = (sum$4[ramp(0, 1, 4)] + (x4(i0[(sum$4.s1.i0.x$r + (sum$4.s1.i0.y$r*3))])*blur_root3[ramp(((((blur_root4.s0.x.v17.base + sum$4.s1.i0.x$r) - blur_root3.x.min_realized) + (((((blur_root4.s0.y.v16.base + blur_root4.s0.y.v16) + sum$4.s1.i0.y$r) - blur_root3.y.min_realized) + -1)*(blur_root3.x.extent_realized.s + 1))) + -1), 1, 4)]))
              }
            }
          }
          blur_root4[ramp(((blur_root4.s0.x.v17.base + ((blur_root4.s0.y.v16.base + blur_root4.s0.y.v16)*blur_root4.stride.1)) - (blur_root4.min.0 + (blur_root4.min.1*blur_root4.stride.1))), 1, 4)] = sum$4[ramp(0, 1, 4)]
          free sum$4
        }
      }
    }
    free blur_root3
  }
  0
}


Embedding image i0
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Compiling to native code...
Injecting realization of sum$4
Injecting realization of blur_tile3
Injecting realization of sum$3
Injecting realization of blur_tile2
Injecting realization of sum$2
Injecting realization of blur_tile1
Injecting realization of sum
Injecting realization of blur_tile0
Injecting tracing...
Injecting profiling...
Adding checks for parameters
Computing bounds of each function's value
Adding checks for images
Performing computation bounds inference...
Performing sliding window optimization...
Performing allocation bounds inference...
Uniquifying variable names...
Performing storage folding optimization...
Injecting debug_to_file calls...
Simplifying...
Dynamically skipping stages...
Performing storage flattening...
Removing code that depends on undef values...
Simplifying...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Specializing clamped ramps...
Injecting early frees...
Simplifying...
Lowering after final simplification:
let blur_tile4.extent.0.required.s = (min((((((blur_tile4.extent.0 + -1)/64)*64) + blur_tile4.min.0) + 63), ((blur_tile4.min.0 + blur_tile4.extent.0) + -1)) - min(blur_tile4.min.0, ((blur_tile4.min.0 + blur_tile4.extent.0) + -64)))
let blur_tile4.min.0.required = min(blur_tile4.min.0, ((blur_tile4.min.0 + blur_tile4.extent.0) + -64))
let blur_tile4.extent.1.required.s = (min((((((blur_tile4.extent.1 + -1)/256)*256) + blur_tile4.min.1) + 255), ((blur_tile4.min.1 + blur_tile4.extent.1) + -1)) - min(blur_tile4.min.1, ((blur_tile4.min.1 + blur_tile4.extent.1) + -256)))
let blur_tile4.min.1.required = min(blur_tile4.min.1, ((blur_tile4.min.1 + blur_tile4.extent.1) + -256))
let p0.extent.0.required.s = (max(min(min((((((blur_tile4.extent.0 + 7)/64)*64) + blur_tile4.min.0) + 59), ((blur_tile4.min.0 + blur_tile4.extent.0) + 3)), (p0.extent.0 + -1)), 0) - max(min(min((blur_tile4.min.0 + -4), ((blur_tile4.min.0 + blur_tile4.extent.0) + -60)), (p0.extent.0 + -1)), 0))
let p0.min.0.required = max(min(min((blur_tile4.min.0 + -4), ((blur_tile4.min.0 + blur_tile4.extent.0) + -60)), (p0.extent.0 + -1)), 0)
let p0.extent.1.required.s = (max(min(min((((((blur_tile4.extent.1 + 7)/256)*256) + blur_tile4.min.1) + 251), ((blur_tile4.min.1 + blur_tile4.extent.1) + 3)), (p0.extent.1 + -1)), 0) - max(min(min((blur_tile4.min.1 + -4), ((blur_tile4.min.1 + blur_tile4.extent.1) + -252)), (p0.extent.1 + -1)), 0))
let p0.min.1.required = max(min(min((blur_tile4.min.1 + -4), ((blur_tile4.min.1 + blur_tile4.extent.1) + -252)), (p0.extent.1 + -1)), 0)
if (blur_tile4.host_and_dev_are_null) {
  rewrite_buffer(blur_tile4.buffer, 2, blur_tile4.min.0.required, (blur_tile4.extent.0.required.s + 1), 1, blur_tile4.min.1.required, (blur_tile4.extent.1.required.s + 1), (blur_tile4.extent.0.required.s + 1))
}
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 3, 1, 0, 3, 3)
}
if (p0.host_and_dev_are_null) {
  rewrite_buffer(p0.buffer, 2, p0.min.0.required, (p0.extent.0.required.s + 1), 1, p0.min.1.required, (p0.extent.1.required.s + 1), (p0.extent.0.required.s + 1))
}
if (!((blur_tile4.host_and_dev_are_null || i0.host_and_dev_are_null) || p0.host_and_dev_are_null)) {
  assert((blur_tile4.elem_size == 2), "Output buffer blur_tile4 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", blur_tile4.elem_size)
  assert((i0.elem_size == 2), "Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", i0.elem_size)
  assert((p0.elem_size == 2), "Input buffer p0 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", p0.elem_size)
  assert((blur_tile4.min.0 <= blur_tile4.min.0.required), "Output buffer blur_tile4 is accessed at %d, which is before the min (%d) in dimension 0", blur_tile4.min.0.required, blur_tile4.min.0)
  assert(((((blur_tile4.min.0.required + blur_tile4.extent.0.required.s) - blur_tile4.extent.0) + 1) <= blur_tile4.min.0), "Output buffer blur_tile4 is accessed at %d, which is beyond the max (%d) in dimension 0", (blur_tile4.min.0.required + blur_tile4.extent.0.required.s), ((blur_tile4.min.0 + blur_tile4.extent.0) + -1))
  assert((blur_tile4.min.1 <= blur_tile4.min.1.required), "Output buffer blur_tile4 is accessed at %d, which is before the min (%d) in dimension 1", blur_tile4.min.1.required, blur_tile4.min.1)
  assert(((((blur_tile4.min.1.required + blur_tile4.extent.1.required.s) - blur_tile4.extent.1) + 1) <= blur_tile4.min.1), "Output buffer blur_tile4 is accessed at %d, which is beyond the max (%d) in dimension 1", (blur_tile4.min.1.required + blur_tile4.extent.1.required.s), ((blur_tile4.min.1 + blur_tile4.extent.1) + -1))
  assert((i0.min.0 <= 0), "Input buffer i0 is accessed at %d, which is before the min (%d) in dimension 0", 0, i0.min.0)
  assert(((3 - i0.extent.0) <= i0.min.0), "Input buffer i0 is accessed at %d, which is beyond the max (%d) in dimension 0", 2, ((i0.min.0 + i0.extent.0) + -1))
  assert((i0.min.1 <= 0), "Input buffer i0 is accessed at %d, which is before the min (%d) in dimension 1", 0, i0.min.1)
  assert(((3 - i0.extent.1) <= i0.min.1), "Input buffer i0 is accessed at %d, which is beyond the max (%d) in dimension 1", 2, ((i0.min.1 + i0.extent.1) + -1))
  assert((p0.min.0 <= p0.min.0.required), "Input buffer p0 is accessed at %d, which is before the min (%d) in dimension 0", p0.min.0.required, p0.min.0)
  assert(((((p0.min.0.required + p0.extent.0.required.s) - p0.extent.0) + 1) <= p0.min.0), "Input buffer p0 is accessed at %d, which is beyond the max (%d) in dimension 0", (p0.min.0.required + p0.extent.0.required.s), ((p0.min.0 + p0.extent.0) + -1))
  assert((p0.min.1 <= p0.min.1.required), "Input buffer p0 is accessed at %d, which is before the min (%d) in dimension 1", p0.min.1.required, p0.min.1)
  assert(((((p0.min.1.required + p0.extent.1.required.s) - p0.extent.1) + 1) <= p0.min.1), "Input buffer p0 is accessed at %d, which is beyond the max (%d) in dimension 1", (p0.min.1.required + p0.extent.1.required.s), ((p0.min.1 + p0.extent.1) + -1))
  assert((blur_tile4.stride.0 == 1), "Static constraint violated: blur_tile4.stride.0 == 1")
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 3), "Static constraint violated: i0.extent.0 == 3")
  assert((i0.stride.1 == 3), "Static constraint violated: i0.stride.1 == 3")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 3), "Static constraint violated: i0.extent.1 == 3")
  assert((p0.stride.0 == 1), "Static constraint violated: p0.stride.0 == 1")
  let blur_tile4.total_extent.1 = (int64(blur_tile4.extent.1)*int64(blur_tile4.extent.0))
  let p0.total_extent.1 = (int64(p0.extent.1)*int64(p0.extent.0))
  assert((int64(blur_tile4.extent.0) <= int64(2147483647)), "Total allocation for buffer blur_tile4 exceeds 2^31 - 1")
  assert(((int64(blur_tile4.extent.1)*int64(blur_tile4.stride.1)) <= int64(2147483647)), "Total allocation for buffer blur_tile4 exceeds 2^31 - 1")
  assert((blur_tile4.total_extent.1 <= int64(2147483647)), "Product of extents for buffer blur_tile4 exceeds 2^31 - 1")
  assert((int64(3) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(3)*int64(3)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(3)*int64(3)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(p0.extent.0) <= int64(2147483647)), "Total allocation for buffer p0 exceeds 2^31 - 1")
  assert(((int64(p0.extent.1)*int64(p0.stride.1)) <= int64(2147483647)), "Total allocation for buffer p0 exceeds 2^31 - 1")
  assert((p0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer p0 exceeds 2^31 - 1")
  let blur_tile0.y.min_realized = min(min((blur_tile4.min.1 + -4), ((blur_tile4.min.1 + blur_tile4.extent.1) + -252)), (min((blur_tile4.min.1 + -3), ((blur_tile4.min.1 + blur_tile4.extent.1) + -253)) + -1))
  let blur_tile0.y.extent_realized.s.s = max(min((((((blur_tile4.extent.1 + 7)/256)*256) + blur_tile4.min.1) + 251), ((blur_tile4.min.1 + blur_tile4.extent.1) + 3)), (min((((((blur_tile4.extent.1 + 5)/256)*256) + blur_tile4.min.1) + 252), ((blur_tile4.min.1 + blur_tile4.extent.1) + 2)) + 1))
  let blur_tile0.x.min_realized = min(min((blur_tile4.min.0 + -4), ((blur_tile4.min.0 + blur_tile4.extent.0) + -60)), (min((blur_tile4.min.0 + -3), ((blur_tile4.min.0 + blur_tile4.extent.0) + -61)) + -1))
  let blur_tile0.x.extent_realized.s.s = max(min((((((blur_tile4.extent.0 + 7)/64)*64) + blur_tile4.min.0) + 59), ((blur_tile4.min.0 + blur_tile4.extent.0) + 3)), (min((((((blur_tile4.extent.0 + 5)/64)*64) + blur_tile4.min.0) + 60), ((blur_tile4.min.0 + blur_tile4.extent.0) + 2)) + 1))
  allocate blur_tile0[uint16 * ((blur_tile0.x.extent_realized.s.s - blur_tile0.x.min_realized) + 1) * ((blur_tile0.y.extent_realized.s.s - blur_tile0.y.min_realized) + 1)]
  produce blur_tile0 {
    parallel (blur_tile0.s0.y.y.y, 0, ((blur_tile4.extent.1 + 263)/256)) {
      let blur_tile0.s0.s4.base = min((((blur_tile0.s0.y.y.y*256) + blur_tile4.min.1) + -4), ((blur_tile4.min.1 + blur_tile4.extent.1) + -252))
      for (blur_tile0.s0.y.y.v11, 0, 4) {
        for (blur_tile0.s0.x.x, 0, ((blur_tile4.extent.0 + 71)/64)) {
          let blur_tile0.s0.x.v9.base = min((((blur_tile0.s0.x.x*64) + blur_tile4.min.0) + -4), ((blur_tile4.min.0 + blur_tile4.extent.0) + -60))
          for (blur_tile0.s0.y.v10, 0, 64) {
            for (blur_tile0.s0.x.v9.v9, 0, 16) {
              if (((((blur_tile0.s0.x.v9.base + (blur_tile0.s0.x.v9.v9*4)) + 4) <= p0.extent.0) && ((0 - (blur_tile0.s0.x.v9.v9*4)) <= blur_tile0.s0.x.v9.base))) {
                blur_tile0[ramp((((blur_tile0.s0.x.v9.base + (blur_tile0.s0.x.v9.v9*4)) - blur_tile0.x.min_realized) + (((blur_tile0.s0.s4.base + ((blur_tile0.s0.y.y.v11*64) + blur_tile0.s0.y.v10)) - blur_tile0.y.min_realized)*((blur_tile0.x.extent_realized.s.s - blur_tile0.x.min_realized) + 1))), 1, 4)] = p0[ramp((((blur_tile0.s0.x.v9.base + (blur_tile0.s0.x.v9.v9*4)) + (max(min((blur_tile0.s0.s4.base + ((blur_tile0.s0.y.y.v11*64) + blur_tile0.s0.y.v10)), (p0.extent.1 + -1)), 0)*p0.stride.1)) - (p0.min.0 + (p0.min.1*p0.stride.1))), 1, 4)]
              } else {
                blur_tile0[ramp((((blur_tile0.s0.x.v9.base + (blur_tile0.s0.x.v9.v9*4)) - blur_tile0.x.min_realized) + (((blur_tile0.s0.s4.base + ((blur_tile0.s0.y.y.v11*64) + blur_tile0.s0.y.v10)) - blur_tile0.y.min_realized)*((blur_tile0.x.extent_realized.s.s - blur_tile0.x.min_realized) + 1))), 1, 4)] = p0[((max(min(ramp((blur_tile0.s0.x.v9.base + (blur_tile0.s0.x.v9.v9*4)), 1, 4), x4((p0.extent.0 + -1))), x4(0)) + x4((max(min((blur_tile0.s0.s4.base + ((blur_tile0.s0.y.y.v11*64) + blur_tile0.s0.y.v10)), (p0.extent.1 + -1)), 0)*p0.stride.1))) - x4((p0.min.0 + (p0.min.1*p0.stride.1))))]
              }
            }
          }
        }
      }
    }
  }
  let blur_tile1.y.min_realized = min(min((blur_tile4.min.1 + -3), ((blur_tile4.min.1 + blur_tile4.extent.1) + -253)), (min((blur_tile4.min.1 + -2), ((blur_tile4.min.1 + blur_tile4.extent.1) + -254)) + -1))
  let blur_tile1.y.extent_realized.s.s = max(min((((((blur_tile4.extent.1 + 5)/256)*256) + blur_tile4.min.1) + 252), ((blur_tile4.min.1 + blur_tile4.extent.1) + 2)), (min((((((blur_tile4.extent.1 + 3)/256)*256) + blur_tile4.min.1) + 253), ((blur_tile4.min.1 + blur_tile4.extent.1) + 1)) + 1))
  let blur_tile1.x.min_realized = min(min((blur_tile4.min.0 + -3), ((blur_tile4.min.0 + blur_tile4.extent.0) + -61)), (min((blur_tile4.min.0 + -2), ((blur_tile4.min.0 + blur_tile4.extent.0) + -62)) + -1))
  let blur_tile1.x.extent_realized.s.s = max(min((((((blur_tile4.extent.0 + 5)/64)*64) + blur_tile4.min.0) + 60), ((blur_tile4.min.0 + blur_tile4.extent.0) + 2)), (min((((((blur_tile4.extent.0 + 3)/64)*64) + blur_tile4.min.0) + 61), ((blur_tile4.min.0 + blur_tile4.extent.0) + 1)) + 1))
  allocate blur_tile1[uint16 * ((blur_tile1.x.extent_realized.s.s - blur_tile1.x.min_realized) + 1) * ((blur_tile1.y.extent_realized.s.s - blur_tile1.y.min_realized) + 1)]
  produce blur_tile1 {
    parallel (blur_tile1.s0.y.y.y, 0, ((blur_tile4.extent.1 + 261)/256)) {
      let blur_tile1.s0.s3.base = min((((blur_tile1.s0.y.y.y*256) + blur_tile4.min.1) + -3), ((blur_tile4.min.1 + blur_tile4.extent.1) + -253))
      for (blur_tile1.s0.y.y.v13, 0, 4) {
        for (blur_tile1.s0.x.x, 0, ((blur_tile4.extent.0 + 69)/64)) {
          let blur_tile1.s0.x.v9.base = min((((blur_tile1.s0.x.x*64) + blur_tile4.min.0) + -3), ((blur_tile4.min.0 + blur_tile4.extent.0) + -61))
          for (blur_tile1.s0.y.v10, 0, 64) {
            let blur_tile1.s0.y.min_4 = (blur_tile1.s0.s3.base + ((blur_tile1.s0.y.y.v13*64) + blur_tile1.s0.y.v10))
            for (blur_tile1.s0.x.v9.v9, 0, 16) {
              let blur_tile1.s0.x.min_6.s = (blur_tile1.s0.x.v9.base + (blur_tile1.s0.x.v9.v9*4))
              allocate sum[uint16 * 4 * 1 * 1]
              produce sum {
                sum[ramp(0, 1, 4)] = x4(uint16(0))
              } update sum {
                for (sum.s1.i0.y$r, 0, 3) {
                  for (sum.s1.i0.x$r, 0, 3) {
                    sum[ramp(0, 1, 4)] = (sum[ramp(0, 1, 4)] + (x4(i0[(sum.s1.i0.x$r + (sum.s1.i0.y$r*3))])*blur_tile0[ramp(((((blur_tile1.s0.x.min_6.s + sum.s1.i0.x$r) - blur_tile0.x.min_realized) + ((((blur_tile1.s0.y.min_4 + sum.s1.i0.y$r) - blur_tile0.y.min_realized) + -1)*((blur_tile0.x.extent_realized.s.s - blur_tile0.x.min_realized) + 1))) + -1), 1, 4)]))
                  }
                }
              }
              blur_tile1[ramp(((blur_tile1.s0.x.min_6.s - blur_tile1.x.min_realized) + ((blur_tile1.s0.y.min_4 - blur_tile1.y.min_realized)*((blur_tile1.x.extent_realized.s.s - blur_tile1.x.min_realized) + 1))), 1, 4)] = sum[ramp(0, 1, 4)]
              free sum
            }
          }
        }
      }
    }
    free blur_tile0
  }
  let blur_tile2.y.min_realized = min(min((blur_tile4.min.1 + -2), ((blur_tile4.min.1 + blur_tile4.extent.1) + -254)), (min((blur_tile4.min.1 + -1), ((blur_tile4.min.1 + blur_tile4.extent.1) + -255)) + -1))
  let blur_tile2.y.extent_realized.s.s = max(min((((((blur_tile4.extent.1 + 3)/256)*256) + blur_tile4.min.1) + 253), ((blur_tile4.min.1 + blur_tile4.extent.1) + 1)), (min((((((blur_tile4.extent.1 + 1)/256)*256) + blur_tile4.min.1) + 254), (blur_tile4.min.1 + blur_tile4.extent.1)) + 1))
  let blur_tile2.x.min_realized = min(min((blur_tile4.min.0 + -2), ((blur_tile4.min.0 + blur_tile4.extent.0) + -62)), (min((blur_tile4.min.0 + -1), ((blur_tile4.min.0 + blur_tile4.extent.0) + -63)) + -1))
  let blur_tile2.x.extent_realized.s.s = max(min((((((blur_tile4.extent.0 + 3)/64)*64) + blur_tile4.min.0) + 61), ((blur_tile4.min.0 + blur_tile4.extent.0) + 1)), (min((((((blur_tile4.extent.0 + 1)/64)*64) + blur_tile4.min.0) + 62), (blur_tile4.min.0 + blur_tile4.extent.0)) + 1))
  allocate blur_tile2[uint16 * ((blur_tile2.x.extent_realized.s.s - blur_tile2.x.min_realized) + 1) * ((blur_tile2.y.extent_realized.s.s - blur_tile2.y.min_realized) + 1)]
  produce blur_tile2 {
    parallel (blur_tile2.s0.y.y.y, 0, ((blur_tile4.extent.1 + 259)/256)) {
      let blur_tile2.s0.s2.base = min((((blur_tile2.s0.y.y.y*256) + blur_tile4.min.1) + -2), ((blur_tile4.min.1 + blur_tile4.extent.1) + -254))
      for (blur_tile2.s0.y.y.v15, 0, 4) {
        for (blur_tile2.s0.x.x, 0, ((blur_tile4.extent.0 + 67)/64)) {
          let blur_tile2.s0.x.v9.base = min((((blur_tile2.s0.x.x*64) + blur_tile4.min.0) + -2), ((blur_tile4.min.0 + blur_tile4.extent.0) + -62))
          for (blur_tile2.s0.y.v10, 0, 64) {
            let blur_tile2.s0.y.min_4 = (blur_tile2.s0.s2.base + ((blur_tile2.s0.y.y.v15*64) + blur_tile2.s0.y.v10))
            for (blur_tile2.s0.x.v9.v9, 0, 16) {
              let blur_tile2.s0.x.min_6.s = (blur_tile2.s0.x.v9.base + (blur_tile2.s0.x.v9.v9*4))
              allocate sum$2[uint16 * 4 * 1 * 1]
              produce sum$2 {
                sum$2[ramp(0, 1, 4)] = x4(uint16(0))
              } update sum$2 {
                for (sum$2.s1.i0.y$r, 0, 3) {
                  for (sum$2.s1.i0.x$r, 0, 3) {
                    sum$2[ramp(0, 1, 4)] = (sum$2[ramp(0, 1, 4)] + (x4(i0[(sum$2.s1.i0.x$r + (sum$2.s1.i0.y$r*3))])*blur_tile1[ramp(((((blur_tile2.s0.x.min_6.s + sum$2.s1.i0.x$r) - blur_tile1.x.min_realized) + ((((blur_tile2.s0.y.min_4 + sum$2.s1.i0.y$r) - blur_tile1.y.min_realized) + -1)*((blur_tile1.x.extent_realized.s.s - blur_tile1.x.min_realized) + 1))) + -1), 1, 4)]))
                  }
                }
              }
              blur_tile2[ramp(((blur_tile2.s0.x.min_6.s - blur_tile2.x.min_realized) + ((blur_tile2.s0.y.min_4 - blur_tile2.y.min_realized)*((blur_tile2.x.extent_realized.s.s - blur_tile2.x.min_realized) + 1))), 1, 4)] = sum$2[ramp(0, 1, 4)]
              free sum$2
            }
          }
        }
      }
    }
    free blur_tile1
  }
  let blur_tile3.y.min_realized = min(min((blur_tile4.min.1 + -1), ((blur_tile4.min.1 + blur_tile4.extent.1) + -255)), (blur_tile4.min.1.required + -1))
  let blur_tile3.y.extent_realized.s = (min(max((((((blur_tile4.extent.1 + 1)/256)*256) + blur_tile4.min.1) + 254), (((((blur_tile4.extent.1 + -1)/256)*256) + blur_tile4.min.1) + 256)), (blur_tile4.min.1 + blur_tile4.extent.1)) - min(min((blur_tile4.min.1 + -1), ((blur_tile4.min.1 + blur_tile4.extent.1) + -255)), (blur_tile4.min.1.required + -1)))
  let blur_tile3.x.min_realized = min(min((blur_tile4.min.0 + -1), ((blur_tile4.min.0 + blur_tile4.extent.0) + -63)), (blur_tile4.min.0.required + -1))
  let blur_tile3.x.extent_realized.s = (min(max((((((blur_tile4.extent.0 + 1)/64)*64) + blur_tile4.min.0) + 62), (((((blur_tile4.extent.0 + -1)/64)*64) + blur_tile4.min.0) + 64)), (blur_tile4.min.0 + blur_tile4.extent.0)) - min(min((blur_tile4.min.0 + -1), ((blur_tile4.min.0 + blur_tile4.extent.0) + -63)), (blur_tile4.min.0.required + -1)))
  allocate blur_tile3[uint16 * (blur_tile3.x.extent_realized.s + 1) * (blur_tile3.y.extent_realized.s + 1)]
  produce blur_tile3 {
    parallel (blur_tile3.s0.y.y.y, 0, ((blur_tile4.extent.1 + 257)/256)) {
      let blur_tile3.s0.s1.base = min((((blur_tile3.s0.y.y.y*256) + blur_tile4.min.1) + -1), ((blur_tile4.min.1 + blur_tile4.extent.1) + -255))
      for (blur_tile3.s0.y.y.v17, 0, 4) {
        for (blur_tile3.s0.x.x, 0, ((blur_tile4.extent.0 + 65)/64)) {
          let blur_tile3.s0.x.v9.base = min((((blur_tile3.s0.x.x*64) + blur_tile4.min.0) + -1), ((blur_tile4.min.0 + blur_tile4.extent.0) + -63))
          for (blur_tile3.s0.y.v10, 0, 64) {
            let blur_tile3.s0.y.min_4 = (blur_tile3.s0.s1.base + ((blur_tile3.s0.y.y.v17*64) + blur_tile3.s0.y.v10))
            for (blur_tile3.s0.x.v9.v9, 0, 16) {
              let blur_tile3.s0.x.min_6.s = (blur_tile3.s0.x.v9.base + (blur_tile3.s0.x.v9.v9*4))
              allocate sum$3[uint16 * 4 * 1 * 1]
              produce sum$3 {
                sum$3[ramp(0, 1, 4)] = x4(uint16(0))
              } update sum$3 {
                for (sum$3.s1.i0.y$r, 0, 3) {
                  for (sum$3.s1.i0.x$r, 0, 3) {
                    sum$3[ramp(0, 1, 4)] = (sum$3[ramp(0, 1, 4)] + (x4(i0[(sum$3.s1.i0.x$r + (sum$3.s1.i0.y$r*3))])*blur_tile2[ramp(((((blur_tile3.s0.x.min_6.s + sum$3.s1.i0.x$r) - blur_tile2.x.min_realized) + ((((blur_tile3.s0.y.min_4 + sum$3.s1.i0.y$r) - blur_tile2.y.min_realized) + -1)*((blur_tile2.x.extent_realized.s.s - blur_tile2.x.min_realized) + 1))) + -1), 1, 4)]))
                  }
                }
              }
              blur_tile3[ramp(((blur_tile3.s0.x.min_6.s - blur_tile3.x.min_realized) + ((blur_tile3.s0.y.min_4 - blur_tile3.y.min_realized)*(blur_tile3.x.extent_realized.s + 1))), 1, 4)] = sum$3[ramp(0, 1, 4)]
              free sum$3
            }
          }
        }
      }
    }
    free blur_tile2
  }
  produce blur_tile4 {
    parallel (blur_tile4.s0.y.y.y, 0, ((blur_tile4.extent.1 + 255)/256)) {
      let blur_tile4.s0.s0.base = min(((blur_tile4.s0.y.y.y*256) + blur_tile4.min.1), ((blur_tile4.min.1 + blur_tile4.extent.1) + -256))
      for (blur_tile4.s0.y.y.v19, 0, 4) {
        for (blur_tile4.s0.x.x, 0, ((blur_tile4.extent.0 + 63)/64)) {
          let blur_tile4.s0.x.v9.base = min(((blur_tile4.s0.x.x*64) + blur_tile4.min.0), ((blur_tile4.min.0 + blur_tile4.extent.0) + -64))
          for (blur_tile4.s0.y.v10, 0, 64) {
            let blur_tile4.s0.y.min_4 = (blur_tile4.s0.s0.base + ((blur_tile4.s0.y.y.v19*64) + blur_tile4.s0.y.v10))
            for (blur_tile4.s0.x.v9.v9, 0, 16) {
              let blur_tile4.s0.x.min_6.s = (blur_tile4.s0.x.v9.base + (blur_tile4.s0.x.v9.v9*4))
              allocate sum$4[uint16 * 4 * 1 * 1]
              produce sum$4 {
                sum$4[ramp(0, 1, 4)] = x4(uint16(0))
              } update sum$4 {
                for (sum$4.s1.i0.y$r, 0, 3) {
                  for (sum$4.s1.i0.x$r, 0, 3) {
                    sum$4[ramp(0, 1, 4)] = (sum$4[ramp(0, 1, 4)] + (x4(i0[(sum$4.s1.i0.x$r + (sum$4.s1.i0.y$r*3))])*blur_tile3[ramp(((((blur_tile4.s0.x.min_6.s + sum$4.s1.i0.x$r) - blur_tile3.x.min_realized) + ((((blur_tile4.s0.y.min_4 + sum$4.s1.i0.y$r) - blur_tile3.y.min_realized) + -1)*(blur_tile3.x.extent_realized.s + 1))) + -1), 1, 4)]))
                  }
                }
              }
              blur_tile4[ramp(((blur_tile4.s0.x.min_6.s + (blur_tile4.s0.y.min_4*blur_tile4.stride.1)) - (blur_tile4.min.0 + (blur_tile4.min.1*blur_tile4.stride.1))), 1, 4)] = sum$4[ramp(0, 1, 4)]
              free sum$4
            }
          }
        }
      }
    }
    free blur_tile3
  }
  0
}


Embedding image i0
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Compiling to native code...
Injecting realization of sum$4
Injecting realization of blur_tile3
Injecting realization of sum$3
Injecting realization of blur_tile2
Injecting realization of sum$2
Injecting realization of blur_tile1
Injecting realization of sum
Injecting realization of blur_tile0
Injecting tracing...
Injecting profiling...
Adding checks for parameters
Computing bounds of each function's value
Adding checks for images
Performing computation bounds inference...
Performing sliding window optimization...
Performing allocation bounds inference...
Uniquifying variable names...
Performing storage folding optimization...
Injecting debug_to_file calls...
Simplifying...
Dynamically skipping stages...
Performing storage flattening...
Removing code that depends on undef values...
Simplifying...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Specializing clamped ramps...
Injecting early frees...
Simplifying...
Lowering after final simplification:
let blur_tile4.extent.0.required.s = (min((((((blur_tile4.extent.0 + -1)/64)*64) + blur_tile4.min.0) + 63), ((blur_tile4.min.0 + blur_tile4.extent.0) + -1)) - min(blur_tile4.min.0, ((blur_tile4.min.0 + blur_tile4.extent.0) + -64)))
let blur_tile4.min.0.required = min(blur_tile4.min.0, ((blur_tile4.min.0 + blur_tile4.extent.0) + -64))
let blur_tile4.extent.1.required.s = (min((((((blur_tile4.extent.1 + -1)/256)*256) + blur_tile4.min.1) + 255), ((blur_tile4.min.1 + blur_tile4.extent.1) + -1)) - min(blur_tile4.min.1, ((blur_tile4.min.1 + blur_tile4.extent.1) + -256)))
let blur_tile4.min.1.required = min(blur_tile4.min.1, ((blur_tile4.min.1 + blur_tile4.extent.1) + -256))
let p0.extent.0.required.s = (max(min(min((((((blur_tile4.extent.0 + 7)/4)*4) + blur_tile4.min.0) + -1), ((blur_tile4.min.0 + blur_tile4.extent.0) + 3)), (p0.extent.0 + -1)), 0) - max(min((min(blur_tile4.extent.0, -4) + blur_tile4.min.0), (p0.extent.0 + -1)), 0))
let p0.min.0.required = max(min((min(blur_tile4.extent.0, -4) + blur_tile4.min.0), (p0.extent.0 + -1)), 0)
let p0.extent.1.required.s = (max(min(((blur_tile4.min.1 + blur_tile4.extent.1) + 3), (p0.extent.1 + -1)), 0) - max(min((blur_tile4.min.1 + -4), (p0.extent.1 + -1)), 0))
let p0.min.1.required = max(min((blur_tile4.min.1 + -4), (p0.extent.1 + -1)), 0)
if (blur_tile4.host_and_dev_are_null) {
  rewrite_buffer(blur_tile4.buffer, 2, blur_tile4.min.0.required, (blur_tile4.extent.0.required.s + 1), 1, blur_tile4.min.1.required, (blur_tile4.extent.1.required.s + 1), (blur_tile4.extent.0.required.s + 1))
}
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 3, 1, 0, 3, 3)
}
if (p0.host_and_dev_are_null) {
  rewrite_buffer(p0.buffer, 2, p0.min.0.required, (p0.extent.0.required.s + 1), 1, p0.min.1.required, (p0.extent.1.required.s + 1), (p0.extent.0.required.s + 1))
}
if (!((blur_tile4.host_and_dev_are_null || i0.host_and_dev_are_null) || p0.host_and_dev_are_null)) {
  assert((blur_tile4.elem_size == 2), "Output buffer blur_tile4 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", blur_tile4.elem_size)
  assert((i0.elem_size == 2), "Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", i0.elem_size)
  assert((p0.elem_size == 2), "Input buffer p0 has type uint16, but elem_size of the buffer_t passed in is %d instead of 2", p0.elem_size)
  assert((blur_tile4.min.0 <= blur_tile4.min.0.required), "Output buffer blur_tile4 is accessed at %d, which is before the min (%d) in dimension 0", blur_tile4.min.0.required, blur_tile4.min.0)
  assert(((((blur_tile4.min.0.required + blur_tile4.extent.0.required.s) - blur_tile4.extent.0) + 1) <= blur_tile4.min.0), "Output buffer blur_tile4 is accessed at %d, which is beyond the max (%d) in dimension 0", (blur_tile4.min.0.required + blur_tile4.extent.0.required.s), ((blur_tile4.min.0 + blur_tile4.extent.0) + -1))
  assert((blur_tile4.min.1 <= blur_tile4.min.1.required), "Output buffer blur_tile4 is accessed at %d, which is before the min (%d) in dimension 1", blur_tile4.min.1.required, blur_tile4.min.1)
  assert(((((blur_tile4.min.1.required + blur_tile4.extent.1.required.s) - blur_tile4.extent.1) + 1) <= blur_tile4.min.1), "Output buffer blur_tile4 is accessed at %d, which is beyond the max (%d) in dimension 1", (blur_tile4.min.1.required + blur_tile4.extent.1.required.s), ((blur_tile4.min.1 + blur_tile4.extent.1) + -1))
  assert((i0.min.0 <= 0), "Input buffer i0 is accessed at %d, which is before the min (%d) in dimension 0", 0, i0.min.0)
  assert(((3 - i0.extent.0) <= i0.min.0), "Input buffer i0 is accessed at %d, which is beyond the max (%d) in dimension 0", 2, ((i0.min.0 + i0.extent.0) + -1))
  assert((i0.min.1 <= 0), "Input buffer i0 is accessed at %d, which is before the min (%d) in dimension 1", 0, i0.min.1)
  assert(((3 - i0.extent.1) <= i0.min.1), "Input buffer i0 is accessed at %d, which is beyond the max (%d) in dimension 1", 2, ((i0.min.1 + i0.extent.1) + -1))
  assert((p0.min.0 <= p0.min.0.required), "Input buffer p0 is accessed at %d, which is before the min (%d) in dimension 0", p0.min.0.required, p0.min.0)
  assert(((((p0.min.0.required + p0.extent.0.required.s) - p0.extent.0) + 1) <= p0.min.0), "Input buffer p0 is accessed at %d, which is beyond the max (%d) in dimension 0", (p0.min.0.required + p0.extent.0.required.s), ((p0.min.0 + p0.extent.0) + -1))
  assert((p0.min.1 <= p0.min.1.required), "Input buffer p0 is accessed at %d, which is before the min (%d) in dimension 1", p0.min.1.required, p0.min.1)
  assert(((((p0.min.1.required + p0.extent.1.required.s) - p0.extent.1) + 1) <= p0.min.1), "Input buffer p0 is accessed at %d, which is beyond the max (%d) in dimension 1", (p0.min.1.required + p0.extent.1.required.s), ((p0.min.1 + p0.extent.1) + -1))
  assert((blur_tile4.stride.0 == 1), "Static constraint violated: blur_tile4.stride.0 == 1")
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 3), "Static constraint violated: i0.extent.0 == 3")
  assert((i0.stride.1 == 3), "Static constraint violated: i0.stride.1 == 3")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 3), "Static constraint violated: i0.extent.1 == 3")
  assert((p0.stride.0 == 1), "Static constraint violated: p0.stride.0 == 1")
  let blur_tile4.total_extent.1 = (int64(blur_tile4.extent.1)*int64(blur_tile4.extent.0))
  let p0.total_extent.1 = (int64(p0.extent.1)*int64(p0.extent.0))
  assert((int64(blur_tile4.extent.0) <= int64(2147483647)), "Total allocation for buffer blur_tile4 exceeds 2^31 - 1")
  assert(((int64(blur_tile4.extent.1)*int64(blur_tile4.stride.1)) <= int64(2147483647)), "Total allocation for buffer blur_tile4 exceeds 2^31 - 1")
  assert((blur_tile4.total_extent.1 <= int64(2147483647)), "Product of extents for buffer blur_tile4 exceeds 2^31 - 1")
  assert((int64(3) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(3)*int64(3)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(3)*int64(3)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(p0.extent.0) <= int64(2147483647)), "Total allocation for buffer p0 exceeds 2^31 - 1")
  assert(((int64(p0.extent.1)*int64(p0.stride.1)) <= int64(2147483647)), "Total allocation for buffer p0 exceeds 2^31 - 1")
  assert((p0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer p0 exceeds 2^31 - 1")
  produce blur_tile4 {
    parallel (blur_tile4.s0.y.y.y, 0, ((blur_tile4.extent.1 + 255)/256)) {
      let blur_tile4.s0.s0.base = min(((blur_tile4.s0.y.y.y*256) + blur_tile4.min.1), ((blur_tile4.min.1 + blur_tile4.extent.1) + -256))
      for (blur_tile4.s0.y.y.v11, 0, 4) {
        let blur_tile4.s0.y.min_2 = (blur_tile4.s0.s0.base + (blur_tile4.s0.y.y.v11*64))
        for (blur_tile4.s0.x.x, 0, ((blur_tile4.extent.0 + 63)/64)) {
          let blur_tile4.s0.x.v9.base = min(((blur_tile4.s0.x.x*64) + blur_tile4.min.0), ((blur_tile4.min.0 + blur_tile4.extent.0) + -64))
          allocate blur_tile0[uint16 * 72 * 72]
          produce blur_tile0 {
            for (blur_tile0.s0.y, (blur_tile4.s0.y.min_2 + -4), 72) {
              for (blur_tile0.s0.x.x, 0, 18) {
                let blur_tile0.s0.x.v13.base = min((((blur_tile0.s0.x.x*4) + blur_tile4.s0.x.v9.base) + -4), (blur_tile4.s0.x.v9.base + 64))
                if ((((blur_tile0.s0.x.v13.base + 4) <= p0.extent.0) && (0 <= blur_tile0.s0.x.v13.base))) {
                  blur_tile0[ramp((((blur_tile0.s0.x.v13.base - blur_tile4.s0.x.v9.base) + ((blur_tile0.s0.y - blur_tile4.s0.y.min_2)*72)) + 292), 1, 4)] = p0[ramp(((blur_tile0.s0.x.v13.base + (max(min(blur_tile0.s0.y, (p0.extent.1 + -1)), 0)*p0.stride.1)) - (p0.min.0 + (p0.min.1*p0.stride.1))), 1, 4)]
                } else {
                  blur_tile0[ramp((((blur_tile0.s0.x.v13.base - blur_tile4.s0.x.v9.base) + ((blur_tile0.s0.y - blur_tile4.s0.y.min_2)*72)) + 292), 1, 4)] = p0[((max(min(ramp(blur_tile0.s0.x.v13.base, 1, 4), x4((p0.extent.0 + -1))), x4(0)) + x4((max(min(blur_tile0.s0.y, (p0.extent.1 + -1)), 0)*p0.stride.1))) - x4((p0.min.0 + (p0.min.1*p0.stride.1))))]
                }
              }
            }
          }
          allocate blur_tile1[uint16 * 70 * 70]
          produce blur_tile1 {
            for (blur_tile1.s0.y, (blur_tile4.s0.y.min_2 + -3), 70) {
              for (blur_tile1.s0.x.x, 0, 18) {
                let blur_tile1.s0.x.v14.base = min((((blur_tile1.s0.x.x*4) + blur_tile4.s0.x.v9.base) + -3), (blur_tile4.s0.x.v9.base + 63))
                allocate sum[uint16 * 4 * 1 * 1]
                produce sum {
                  sum[ramp(0, 1, 4)] = x4(uint16(0))
                } update sum {
                  for (sum.s1.i0.y$r, 0, 3) {
                    for (sum.s1.i0.x$r, 0, 3) {
                      sum[ramp(0, 1, 4)] = (sum[ramp(0, 1, 4)] + (x4(i0[(sum.s1.i0.x$r + (sum.s1.i0.y$r*3))])*blur_tile0[ramp(((((blur_tile1.s0.x.v14.base + sum.s1.i0.x$r) - blur_tile4.s0.x.v9.base) + (((blur_tile1.s0.y + sum.s1.i0.y$r) - blur_tile4.s0.y.min_2)*72)) + 219), 1, 4)]))
                    }
                  }
                }
                blur_tile1[ramp((((blur_tile1.s0.x.v14.base - blur_tile4.s0.x.v9.base) + ((blur_tile1.s0.y - blur_tile4.s0.y.min_2)*70)) + 213), 1, 4)] = sum[ramp(0, 1, 4)]
                free sum
              }
            }
            free blur_tile0
          }
          allocate blur_tile2[uint16 * 68 * 68]
          produce blur_tile2 {
            for (blur_tile2.s0.y, (blur_tile4.s0.y.min_2 + -2), 68) {
              for (blur_tile2.s0.x.x, 0, 17) {
                let blur_tile2.s0.x.v15.base = min((((blur_tile2.s0.x.x*4) + blur_tile4.s0.x.v9.base) + -2), (blur_tile4.s0.x.v9.base + 62))
                allocate sum$2[uint16 * 4 * 1 * 1]
                produce sum$2 {
                  sum$2[ramp(0, 1, 4)] = x4(uint16(0))
                } update sum$2 {
                  for (sum$2.s1.i0.y$r, 0, 3) {
                    for (sum$2.s1.i0.x$r, 0, 3) {
                      sum$2[ramp(0, 1, 4)] = (sum$2[ramp(0, 1, 4)] + (x4(i0[(sum$2.s1.i0.x$r + (sum$2.s1.i0.y$r*3))])*blur_tile1[ramp(((((blur_tile2.s0.x.v15.base + sum$2.s1.i0.x$r) - blur_tile4.s0.x.v9.base) + (((blur_tile2.s0.y + sum$2.s1.i0.y$r) - blur_tile4.s0.y.min_2)*70)) + 142), 1, 4)]))
                    }
                  }
                }
                blur_tile2[ramp((((blur_tile2.s0.x.v15.base - blur_tile4.s0.x.v9.base) + ((blur_tile2.s0.y - blur_tile4.s0.y.min_2)*68)) + 138), 1, 4)] = sum$2[ramp(0, 1, 4)]
                free sum$2
              }
            }
            free blur_tile1
          }
          allocate blur_tile3[uint16 * 66 * 66]
          produce blur_tile3 {
            for (blur_tile3.s0.y, (blur_tile4.s0.y.min_2 + -1), 66) {
              for (blur_tile3.s0.x.x, 0, 17) {
                let blur_tile3.s0.x.v16.base = min((((blur_tile3.s0.x.x*4) + blur_tile4.s0.x.v9.base) + -1), (blur_tile4.s0.x.v9.base + 61))
                allocate sum$3[uint16 * 4 * 1 * 1]
                produce sum$3 {
                  sum$3[ramp(0, 1, 4)] = x4(uint16(0))
                } update sum$3 {
                  for (sum$3.s1.i0.y$r, 0, 3) {
                    for (sum$3.s1.i0.x$r, 0, 3) {
                      sum$3[ramp(0, 1, 4)] = (sum$3[ramp(0, 1, 4)] + (x4(i0[(sum$3.s1.i0.x$r + (sum$3.s1.i0.y$r*3))])*blur_tile2[ramp(((((blur_tile3.s0.x.v16.base + sum$3.s1.i0.x$r) - blur_tile4.s0.x.v9.base) + (((blur_tile3.s0.y + sum$3.s1.i0.y$r) - blur_tile4.s0.y.min_2)*68)) + 69), 1, 4)]))
                    }
                  }
                }
                blur_tile3[ramp((((blur_tile3.s0.x.v16.base - blur_tile4.s0.x.v9.base) + ((blur_tile3.s0.y - blur_tile4.s0.y.min_2)*66)) + 67), 1, 4)] = sum$3[ramp(0, 1, 4)]
                free sum$3
              }
            }
            free blur_tile2
          }
          for (blur_tile4.s0.y.v10, 0, 64) {
            let blur_tile4.s0.y.min_4 = (blur_tile4.s0.s0.base + ((blur_tile4.s0.y.y.v11*64) + blur_tile4.s0.y.v10))
            for (blur_tile4.s0.x.v9.v9, 0, 16) {
              let blur_tile4.s0.x.min_6.s = (blur_tile4.s0.x.v9.base + (blur_tile4.s0.x.v9.v9*4))
              allocate sum$4[uint16 * 4 * 1 * 1]
              produce sum$4 {
                sum$4[ramp(0, 1, 4)] = x4(uint16(0))
              } update sum$4 {
                for (sum$4.s1.i0.y$r, 0, 3) {
                  for (sum$4.s1.i0.x$r, 0, 3) {
                    sum$4[ramp(0, 1, 4)] = (sum$4[ramp(0, 1, 4)] + (x4(i0[(sum$4.s1.i0.x$r + (sum$4.s1.i0.y$r*3))])*blur_tile3[ramp((((blur_tile4.s0.x.min_6.s + sum$4.s1.i0.x$r) - blur_tile4.s0.x.v9.base) + (((blur_tile4.s0.y.min_4 + sum$4.s1.i0.y$r) - blur_tile4.s0.y.min_2)*66)), 1, 4)]))
                  }
                }
              }
              blur_tile4[ramp(((blur_tile4.s0.x.min_6.s + (blur_tile4.s0.y.min_4*blur_tile4.stride.1)) - (blur_tile4.min.0 + (blur_tile4.min.1*blur_tile4.stride.1))), 1, 4)] = sum$4[ramp(0, 1, 4)]
              free sum$4
            }
          }
          free blur_tile3
        }
      }
    }
  }
  0
}


Embedding image i0
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Compiling to native code...
